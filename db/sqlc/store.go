package db

import (
	"context"
	"database/sql"
	"errors"
	"fmt"
)

var ErrNoProductStock error = errors.New("error: not enough product stock available")

// Store provides all the functions to run db queries individually as well as in combination as a transaction
// The Queries struct generated by SQLC doesn't support transaction. So we will embed it in the Store struct
type Store struct {
	*Queries
	db *sql.DB // We need the sql.DB object to create a new transaction
}

/*NewStore Creates and returns a new Store object
@param db *sql.DB the sql.DB object as a pointer
@return *Store returns the newly generated store
*/
func NewStore(db *sql.DB) *Store {
	return &Store{
		db:      db,
		Queries: New(db), // New creates and returns a queries object
	}
}

/*execTx Executes a function within a database transaction
@receiver store *Store
@param ctx Context The context executing the function
@param fn func The Query function
@return error Return any errors
*/
func (store *Store) execTx(ctx context.Context, fn func(*Queries) error) error {
	tx, err := store.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}

	q := New(tx) // create a new Queries object but instead of passing in sql.DB, we are passing in a sql.Tx Object for transactions
	err = fn(q)  // call the input function as queries
	// If there was an error with the transaction
	if err != nil {
		if rollbackErr := tx.Rollback(); rollbackErr != nil {
			return fmt.Errorf("tx error: %v, rollback error: %v", err, rollbackErr)
		}
		return err
	}
	return tx.Commit()
}

//AddToCartTxParams contains the input parameters of the transfer transaction
type AddToCartTxParams struct {
	ProductID int64 `json:"product_id"`
	OrderID   int64 `json:"order_id"`
	Quantity  int64 `json:"quantity"`
}

// AddToCartTxResult is the result of the AddToCartTx transaction
type AddToCartTxResult struct {
	Product     Product     `json:"product"`
	OrderDetail OrderDetail `json:"order_detail"`
	Order       Order       `json:"order"`
	Quantity    int64       `json:"quantity"`
}

func (store *Store) AddToOrderTx(ctx context.Context, arg AddToCartTxParams) (AddToCartTxResult, error) {
	var result AddToCartTxResult

	err := store.execTx(ctx, func(q *Queries) error {
		var err error
		result.Quantity = arg.Quantity

		prod1, err := q.GetProductForUpdate(ctx, arg.ProductID)
		if err != nil {
			return err
		}

		if prod1.ProductStock-arg.Quantity < 0 {
			return ErrNoProductStock
		}

		result.Product, err = q.UpdateProductInventory(ctx, UpdateProductInventoryParams{
			ProductID:    prod1.ProductID,
			ProductStock: prod1.ProductStock - arg.Quantity,
		})

		result.Order, err = q.GetOrder(ctx, arg.OrderID)
		if err != nil {
			return err
		}

		result.OrderDetail, err = q.CreateOrderDetail(ctx, CreateOrderDetailParams{
			DetailOrderID:     result.Order.OrderID,
			DetailProductID:   prod1.ProductID,
			DetailProductName: result.Product.ProductName,
			DetailSku:         result.Product.ProductSku,
			DetailUnitPrice:   result.Product.ProductPrice,
			DetailQuantity:    arg.Quantity,
		})
		if err != nil {
			return err
		}

		return nil
	})

	return result, err
}
